---
layout: post
title:  "Chap.15-1 ROD-CUT"
date:   2018-04-27 02:30:59 +0800
categories: CLRS
---

### 提纲
*  为什么该问题可以用动态规划的思想解决
*  在使用动态规划思想解决该问题时，自顶向下和自底向上有什么区别？

### 练习
1.  **由公式(15.3)和初始条件T(0)=1，证明公式(15.4)成立。**
<br><br> T(n) = 1 + { T(0) + T(1) +...+ T(n-1) }，T(n+1) = 1 +  { T(0) + T(1) +...+ T(n-1) } + T(n) = 2*T(n) , 后一项是前一项的 2 倍，且 T(0) = 1，得证。

2.   **举反例证明下面的“贪心”策略不能保证总是得到最优切割方案。定义长度为i的钢条的密度pi/i，即每英寸的价值。贪心策略将长度为n的钢条切割下长度为i(1<i<n)的一段，其密度最高。接下来继续使用相同的策略切割长度为n-i的剩余部分。**
<br><br> 略

3.   **我们对钢条切割问题进行一点修改，除了切割下的钢条段具有不同价格pi外，每次切割还要付出固定的成本c.这样，切割方案的收益就等于钢条段价格之和减去切割的成本。设计一个动态规划算法解决修改后的钢条切割问题。**
<br><br> Rn = max { Pn , R(1)+R(n-1)-C , R(2)+R(n-2)-C , ... ,R(n-1)+R(1)-C }

4.   **修改MEMOIZED-CUT-ROD，使之不仅返回最优收益值，还返回切割方案。**
<br><br> 通过对 S[i] 递归，找出最优方案下切割点的位置，依次输出。

5.   **斐波那契额数列可以用递归式F(0)=0,F(1)=1,F(n)=F(n-1)+F(n-2).定义。设计一个O(n)时间的动态规划算法计算第n个斐波那契数。画出子问题图。图中有多少顶点和边？**
<br><br> 设置两个变量储存最新两个元素的值，从 0，1 开始，不断更新这两个变量。
```java
  int Fib ( n ) {
    int before = 0, after = 1, result;
    if ( n == 0)  return before;
    if ( n == 1)  return after;
    for ( i = 2; i < n ; i++ ) {
        result = before + after;
        before = after;
        after = result;
    }
    return result;
  }
```
