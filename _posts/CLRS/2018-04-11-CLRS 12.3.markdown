---
layout: post
title:  "《CLRS》 Chap.12-3 Exercises"
date:   2018-04-11 02:30:59 +0800
categories: CLRS
---
##### **12.3-1 给出一个“插入”过程的递归版本**
```java
  // 先给 root 这棵树加满 NIL 叶节点（key = "nil"）
  void TREE_INSERTION (root, v){
    if(!root){
      // 空树，直接赋值
      root = v;
    }else if(root.key == "nil"){
      //到底了，替换该叶节点
      if(root.p.left == root){
        root.p.left = v;
      }else{
        root.p.right = v;
      }
      v.p = root.p;
    }else if(v.key < root.key){
      TREE_INSERTION(root.left, v);
    }else{
      TREE_INSERTION(root.right, v);
    }
  }
```

##### **12.3-2 假设我们通过反复插入不同的关键字的做法来构造一棵二叉查找树。论证：为在树中查找一个关键字，所检查的结点数等于插入该关键字时所检查的结点数加1**
答：查找到某一元素与找到该元素插入位置之前一个节点的路径是完全一样的，得证。

##### **12.3-3 对 n 个关键字集合建立二叉搜索树并通过中序遍历输出该集合的升（降）序排列，该操作的最好、最坏情况下的时间复杂度分别为多少?**

答：通过观察可知，若一个二叉搜索树左右完全“平衡”，则向其插入关键字时所需的比较次数（路径）为 O(lgn)，插入 n 个关键字的总比较次数为 n*O(lgn) = O(nlgn); 若一个二叉搜索树失去平衡完全倾向于一边，则每次插入关键字时的比较次数要比上一多“1”，因此有总比较次数：Sum(n) = 0+1+2..+n = <del>O(n^2)</del>Θ(n^2)。而当树生成后遍历输出时的过程与构建时基本一致，故可知最好情况下时间复杂度为:O(nlgn)，最差为:O(n^2);

##### **12.3-4 删除操作可以交换顺序吗？**

答：删除操作分为四种基本情况，前三种很简单且跟顺序无关。对于第四种也就是待删除节点的后继不是其右孩子的情况有可能出现不同的树结构。

##### **12.3-5 假设为每个节点换一种设计，属性x.p指向x的父节点，属性x.succ指向x的后继。试给出使用这种表示法的二叉搜索树T上SEARCH,INSERT和DELETE操作的伪代码。这些伪代码应在O(h)时间内执行完，其中h为T的高度。(提示：应该设计一个返回某个结点的双亲的子过程。)**

答：搜索比较简单。插入和删除操作都需要维护节点中的 succ 属性，比较省事儿的做法是利用 TREE_SUCCESSOR 方法更新 succ 的指针，但时间复杂度太高。

##### **12.3-6 当TREE-DELETE中的结点z有两个子结点时，可以将其前驱(而不是后继)拼接掉。有些人提出一种公平的策略，即为前驱和后继结点赋予相同的优先级，从而可以得到更好的经验性能。那么，应如何修改TREE-DELETE来实现这样一种公平策略**

答：没看懂，草泥马。
